@top Grammar { declaration* }

@skip { whitespace | LineComment | BlockComment }

@precedence {
  call
  namespace
  inline
  repeat
  seq @left
  choice @left

  scopedSkip
}

declaration[@isGroup=Declaration] {
  RuleDeclaration |
  TopRuleDeclaration { at<"@top"> RuleName Props? ParamList? Body } |
  PrecedenceDeclaration {
    at<"@precedence"> PrecedenceBody {
      "{" (Precedence { PrecedenceName (at<"@left"> | at<"@right"> | at<"@cut">)? } ","?)* "}"
    }
  } |
  TokensDeclaration {
    at<"@tokens"> TokensBody { "{" tokenDeclaration* "}" }
  } |
  ExternalTokensDeclaration {
    at<"@external"> kw<"tokens"> Name kw<"from"> Literal TokensBody {
      "{" (Token { RuleName Props? } ","?)* "}"
    }
  } |
  ExternalGrammarDeclaration {
    at<"@external"> kw<"grammar"> Name (kw<"as"> Name)? (kw<"from"> Literal | kw<"empty">)
  } |
  ExternalPropDeclaration {
    at<"@external"> kw<"prop"> Name (kw<"as"> Name)? kw<"from"> Literal
  } |
  ExternalSpecializeDeclaration {
    at<"@external"> (kw<"extend"> | kw<"specialize">) Body Name kw<"from"> Literal
  } |
  ContextDeclaration {
    at<"@context"> Name kw<"from"> Literal
  } |
  DialectsDeclaration {
    at<"@dialects"> DialectBody { "{" (Name ","?)* "}" }
  } |
  TopSkipDeclaration {
    at<"@skip"> Body
  } |
  SkipScope {
    at<"@skip"> Body !scopedSkip SkipBody { "{" RuleDeclaration* "}" }
  }
}

tokenDeclaration[@isGroup=TokenDeclaration] {
  TokenPrecedenceDeclaration {
    at<"@precedence"> PrecedenceBody { "{" ((Literal | nameExpression) ","?)* "}" }
  } |
  TokenConflictDeclaration {
    at<"@conflict"> ConflictBody { "{" (Literal | nameExpression) ","? (Literal | nameExpression) "}" }
  } |
  LiteralTokenDeclaration {
    Literal Props?
  } |
  TokenRuleDeclaration { RuleName Props? ParamList? Body }
}

RuleDeclaration { RuleName Props? ParamList? Body }

ParamList { "<" (Name ("," Name)*)? ">" }

Body { "{" expression? "}" }

Props { "[" ((Prop ",")* Prop)? "]" }

Prop { (AtName | Name) ("=" (Literal | Name | "." | PropEsc { "{" RuleName "}" })*)? }

expression[@isGroup=Expression] { // FIXME empty expressions
  Literal |
  CharSet |
  AnyChar |
  InvertedCharSet |
  nameExpression |
  Optional { expression !repeat "?" } |
  Repeat { expression !repeat "*" } |
  Repeat1 { expression !repeat "+" } |
  Sequence {
    marker (!seq (expression | marker))* |
    expression (!seq (expression | marker))+
  } |
  InlineRule { (RuleName !inline Props? | Props) Body } |
  Choice { expression (!choice "|" expression)+ } |
  ParenExpression { "(" expression? ")" }
}

nameExpression {
  RuleName |
  ScopedName |
  Call { (RuleName | ScopedName) !call ArgList }
}

marker {
  PrecedenceMarker { "!" PrecedenceName } |
  AmbiguityMarker { "~" Name }
}

ScopedName { RuleName !namespace "." RuleName }

ArgList {
  "<" (expression ("," expression)*)? ">"
}

RuleName { name }

PrecedenceName { name }

Name { name }

kw<value> { @specialize[@name={value}]<keyword, value> }

at<value> { @specialize[@name={value}]<AtName, value> }

@tokens {
  whitespace { std.whitespace+ }

  LineComment { "//" ![\n]* }

  BlockComment { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  nameChar { std.asciiLetter | $[_\u{a1}-\u{10ffff}] }

  name { nameChar (nameChar | std.digit)* }

  AnyChar { "_" }

  @precedence { AnyChar, whitespace, name }

  keyword { name }

  @precedence { whitespace, keyword }

  AtName { "@" name }

  Literal {
    '"' (![\\\n"] | "\\" _)* '"'? |
    "'" (![\\\n'] | "\\" _)* "'"?
  }

  CharSet { "$[" (![\\\]] | "\\" _)* "]" }
  InvertedCharSet { "![" (![\\\]] | "\\" _)* "]" }

  @precedence { InvertedCharSet, "!" }

  "=" "." "|" "!" "~" "*" "+" "?"
}

@detectDelim
